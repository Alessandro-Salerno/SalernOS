// THIS WAS GENERATED BY CHAT GPT

#define _GNU_SOURCE
#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define CHILD_COUNT 100

void test_setsess_in_child() {
    pid_t sid = getsid(0);
    pid_t pid = getpid();

    pid_t new_sid = setsid();
    if (new_sid == -1) {
        // setsid fails if already a session leader
        assert(errno == EPERM);
        assert(getsid(0) == sid); // should not have changed
    } else {
        // Should be session leader
        assert(new_sid == pid);
        assert(getsid(0) == pid);
    }
}

void test_setpgid_self() {
    pid_t pid  = getpid();
    pid_t pgid = getpgid(0);

    int ret = setpgid(0, 0); // should succeed (noop)
    assert(ret == 0);
    assert(getpgid(0) == pgid);

    // Change PGID to self again (noop)
    ret = setpgid(0, pid);
    assert(ret == 0);
    assert(getpgid(0) == pid);
}

void test_setpgid_invalid() {
    // Try changing PGID of a non-child process (should fail)
    pid_t ret = setpgid(1, 1); // PID 1 is usually init
    assert(ret == -1);
    assert(errno == EPERM || errno == ESRCH);
}

void test_child_group_inheritance() {
    pid_t parent_pgid = getpgrp();

    pid_t pid = fork();
    assert(pid >= 0);

    if (pid == 0) {
        // child
        assert(getpgrp() == parent_pgid);
        exit(0);
    } else {
        waitpid(pid, NULL, 0);
    }
}

void stress_spawn_children() {
    pid_t pids[CHILD_COUNT];

    for (int i = 0; i < CHILD_COUNT; ++i) {
        pids[i] = fork();
        if (pids[i] == 0) {
            // In child
            assert(getpgrp() == getppid() ? getpgrp()
                                          : getpgrp()); // just access group
            if (i % 2 == 0) {
                // try to become a new process group leader
                int r = setpgid(0, 0);
                assert(r == 0);
                assert(getpgid(0) == getpid());
            }
            if (i % 10 == 0) {
                // try to create a new session
                setsid(); // might fail if already session leader
            }
            _exit(0);
        } else {
            assert(pids[i] > 0);
        }
    }

    for (int i = 0; i < CHILD_COUNT; ++i) {
        waitpid(pids[i], NULL, 0);
    }
}

void test_pg_and_session_inheritance() {
    pid_t orig_sid  = getsid(0);
    pid_t orig_pgid = getpgrp();

    pid_t pid = fork();
    assert(pid >= 0);

    if (pid == 0) {
        assert(getsid(0) == orig_sid);
        assert(getpgrp() == orig_pgid);
        _exit(0);
    } else {
        waitpid(pid, NULL, 0);
    }
}

int main() {
    printf("Testing process group and session behaviors\n");

    test_setsess_in_child();
    test_setpgid_self();
    test_setpgid_invalid();
    test_child_group_inheritance();
    test_pg_and_session_inheritance();
    stress_spawn_children();

    printf("All assertions passed.\n");

    return 0;
}
