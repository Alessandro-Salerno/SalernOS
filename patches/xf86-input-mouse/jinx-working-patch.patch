diff -uNr xf86-input-mouse-clean/configure xf86-input-mouse-workdir/configure
--- xf86-input-mouse-clean/configure	2023-05-05 02:25:26.000000000 +0200
+++ xf86-input-mouse-workdir/configure	2023-05-05 02:25:26.000000000 +0200
@@ -19591,7 +19591,7 @@
 
 # X Server SDK location is required to install xf86-mouse-properties.h
 # This location is also relayed in the xorg-mouse.pc file
-sdkdir=`$PKG_CONFIG --variable=sdkdir xorg-server`
+sdkdir="$includedir"
 
 # Workaround overriding sdkdir to be able to create a tarball when user has no
 # write permission in sdkdir. See DISTCHECK_CONFIGURE_FLAGS in Makefile.am
@@ -19619,6 +19619,9 @@
   gnu*)
     OS_MOUSE_NAME=hurd
     ;;
+  salernos*)
+    OS_MOUSE_NAME=salernos
+    ;;
 esac
 
 
diff -uNr xf86-input-mouse-clean/src/salernos_mouse.c xf86-input-mouse-workdir/src/salernos_mouse.c
--- xf86-input-mouse-clean/src/salernos_mouse.c	1970-01-01 01:00:00.000000000 +0100
+++ xf86-input-mouse-workdir/src/salernos_mouse.c	2025-09-11 18:41:54.706607133 +0200
@@ -0,0 +1,110 @@
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <xorg-server.h>
+
+#include "xf86_OSlib.h"
+
+#include "inputstr.h"
+#include "mipointer.h"
+#include "mouse.h"
+#include "scrnintstr.h"
+#include "xf86.h"
+#include "xf86Xinput.h"
+#include "xisb.h"
+
+#define MOUSE_RIGHTBUTTON 0x01
+#define MOUSE_MIDBUTTON   0x02
+#define MOUSE_LEFTBUTTON  0x04
+#define MOUSE_BUTTON4     0x08
+#define MOUSE_BUTTON5     0x10
+
+struct salernos_mouse_data {
+    void *reserved;
+    int   buttons;
+    int   dx;
+    int   dy;
+    int   dz;
+};
+
+static void salernosReadInput(InputInfoPtr pInfo) {
+    MouseDevPtr                mouse = pInfo->private;
+    struct salernos_mouse_data packet;
+
+    if (read(pInfo->fd, &packet, sizeof(struct salernos_mouse_data))) {
+        int b = mouse->lastButtons;
+        b &= ~0x7;
+        b |= packet.buttons;
+        mouse->PostEvent(pInfo, b, packet.dx, packet.dy, packet.dz, 0);
+    }
+}
+
+static Bool salernosPreInit(InputInfoPtr pInfo, const char *proto, int flag) {
+    MouseDevPtr mouse;
+
+    mouse = pInfo->private;
+
+    mouse->protocol = proto;
+
+    xf86ProcessCommonOptions(pInfo, pInfo->options);
+
+    pInfo->fd = xf86OpenSerial(pInfo->options);
+    if (pInfo->fd == -1) {
+        xf86Msg(X_ERROR, "%s: cannot open mouse device!\n", pInfo->name);
+        return FALSE;
+    }
+
+    mouse->CommonOptions(pInfo);
+    pInfo->read_input = salernosReadInput;
+    return true;
+}
+
+#define DEVPATH "/dev/mouse0"
+
+static const char *getdevice(InputInfoPtr pInfo, const char *proto, int flag) {
+    pInfo->options = xf86AddNewOption(pInfo->options, "Device", DEVPATH);
+    return DEVPATH;
+}
+
+static int interfacesupport() {
+    return MSE_PS2;
+}
+
+static const char *names[] = {"SalernOSMouseDev", NULL};
+
+static const char **protonames() {
+    return names;
+}
+
+static const char *defaultproto() {
+    return "SalernOSMouseDev";
+}
+
+static Bool isdefault(const char *protocol) {
+    return strcmp(protocol, defaultproto()) == 0;
+}
+
+OSMouseInfoPtr OSMouseInit(int flag) {
+    OSMouseInfoPtr p;
+
+    p = calloc(sizeof(OSMouseInfoRec), 1);
+
+    if (p == NULL)
+        return NULL;
+
+    p->SupportedInterfaces = interfacesupport;
+    p->BuiltinNames        = protonames;
+    p->FindDevice          = getdevice;
+    p->DefaultProtocol     = defaultproto;
+    p->CheckProtocol       = isdefault;
+    p->PreInit             = salernosPreInit;
+    return p;
+}
